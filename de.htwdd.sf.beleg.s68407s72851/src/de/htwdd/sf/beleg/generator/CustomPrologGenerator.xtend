/*
 * generated by Xtext 2.11.0
 */
package de.htwdd.sf.beleg.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import de.htwdd.sf.beleg.customProlog.Atom
import de.htwdd.sf.beleg.customProlog.Fact
import org.eclipse.emf.ecore.EObject
import de.htwdd.sf.beleg.customProlog.Clause
import de.htwdd.sf.beleg.customProlog.Predicate
import de.htwdd.sf.beleg.customProlog.Term
import de.htwdd.sf.beleg.customProlog.Query
import de.htwdd.sf.beleg.customProlog.Prologdsl
import de.htwdd.sf.beleg.customProlog.Program
import de.htwdd.sf.beleg.customProlog.Model
import org.eclipse.emf.common.util.EList
import de.htwdd.sf.beleg.customProlog.Rule

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class CustomPrologGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		var text = ""
		for (e : resource.allContents.toIterable.filter(Prologdsl))
			text += e.transpile + " "
		println(text)
	}

	def transpileClauses(EList<Clause> clauses) {
		var ret = ""
		ret += '('
		for (Clause c : clauses) {
			if (c.fact?.predicate !== null) {
				ret += '(' + transpilePredicates(c.fact?.predicate) + ')' // fancy ? operator checks if fact is null :)
				ret += '\n'
			}
			ret += transpileRule(c?.rule)
		}
		return ret
	}

	def transpileRule(Rule rule) {
		var ret = ""
		if (rule !== null) {
			ret += '('
			ret += transpilePredicates(rule.rule)
			ret += transpileQuery(rule.query)
			ret += ')'
		}
		return ret
	}

	def transpilePredicates(Predicate predicate) {
		var ret = ""
		if (predicate !== null && predicate.functor.functor !== null) {
			ret += '(' + predicate.functor.functor + ' '
			for (Term t : predicate?.term)
				ret += ' ' + t.atom.ident
			ret += ')'
		}
		return ret
	}

	def dispatch transpile(Fact f) {
		return "Fact"
	}

	def dispatch transpile(Term t) {
		return "Term"
	}

	def transpileQuery(Query q) {
		var ret = "("
		for (p : q.p) {
			ret += transpilePredicates(p)
		}
		ret += ')'
		return ret

	}

	def dispatch transpile(Prologdsl p) {
		var ret = '( prolog (quote ' + transpileClauses(p.program.clauses) + ')' + '\n' + '(quote ' +
			transpileQuery(p?.exquery.query)
		ret += '))'
		return ret
	}

	def dispatch transpile(Program p) {
		return "Program"
	}

	def dispatch transpile(Model m) {
		return "Model"
	}
}
